process
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <stdlib.h>

int main() {
    pid_t pid; 
    pid = fork();
    if (pid < 0) {
        perror("Fork failed");
        exit(EXIT_FAILURE);
    } else if (pid == 0) {
        printf("Child process:\n");
        printf("PID: %d\n", getpid());        
        printf("Parent PID: %d\n", getppid()); 
    } else {
        printf("Parent process:\n");
        printf("PID: %d\n", getpid());        
        printf("Child PID: %d\n", pid);      
    }

    return 0;
}

producer consumer
#include <stdio.h>
#include <unistd.h>
int main(){
    int in,out,buffer[100],buff,choice=0,n,i,produce,consume;
    in=0;
    out=0;
    buff=10;
    while(choice!=3){
        printf("\n1. produce  2.consume  3.exit");
        printf("\nenter the choice");
        scanf("%d",&choice);
        switch(choice){
            case 1: if((in+1)%buff==out){
                printf("full");
                
            }
            else{
                printf("\nenter the value");
                scanf("%d",&produce);
                buffer[in]=produce;
                in=(in+1)%buff;
            }
            break;
            case 2:
            if(in==out){
                printf("\nempty");
            }
            else{
                consume=buffer[out];
                printf("\nthe consumed value %d",consume);
                out=(out+1)%buff;
            }
        }
    }
    
}

BANKERS ALGORITHM

#include <stdio.h>
int main(){
    int i,j,r,k,n;
    n=5;
    r=3;
    
    int alloc[5][3] = { { 0, 0, 1 },
						{ 3, 0, 0 }, 
						{ 1, 0, 1 },  
						{ 2, 3, 2 }, 
						{ 0, 0, 3 } };  
    int max[5][3] = { { 7, 6, 3 }, 
					{ 3, 2, 2 },  
					{ 8, 0, 2 },  
					{ 2, 1, 2 },  
					{ 5, 2, 3 } }; 
    int avail[3] = { 2, 3, 2 };
    int f[n],ans[n],ind=0;
    for(k=0;k<n;k++){
        f[k]=0;
    }
    int need[n][r];
    for(int i=0;i<n;i++){
        for(j=0;j<r;j++){
            need[i][j]=max[i][j]-alloc[i][j];
        }
    }
    int y=0;
    for(k=0;k<5;k++){
        for(i=0;i<n;i++){
            if(f[i]==0){
                int flag=0;
                for(j=0;j<r;j++){
                    if(need[i][j]>avail[j]){
                        flag=1;
                        break;
                    }
                }
                if(flag==0){
                    ans[ind++]=i;
                    for(int y=0;y<r;y++)
                    avail[y]+=alloc[i][y];
                    f[i]=1;
                }
            }
        }
    }
    printf("safe sequence");
    for(int i=0;i<n-1;i++)
    printf("p%d ->",ans[i]);
    printf("p%d",ans[n-1]);
}


SHARED MEMORY

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <sys/shm.h>
int main(){
    int i;
    void *sm;
    char buff[100];
    int shmid;
    shmid=shmget((key_t)2345,1024,0666|IPC_CREAT);
    printf(" key %d",shmid);
    sm=shmat(shmid,NULL,0);
    printf("process id %p",sm);
    printf("enter the data");
    read(0,buff,100);
    strcpy(sm,buff);
    printf("you wrote %s",(char*)sm);
}


MULTITHREADS
#include <stdio.h>
#include <pthread.h>
void* thread_func(void* arg){
    printf("threads %d running\n",*(int*)arg);
    pthread_exit(NULL);
}
int main(){
    pthread_t t1,t2;
    int id1=1,id2=2;
    pthread_create(&t1,NULL,thread_func,&id1);
    pthread_create(&t2,NULL,thread_func,&id2);
    pthread_join(t1,NULL);
    pthread_join(t2,NULL);
    if(pthread_equal(t1,t2)){
        printf("equal");
    }
    else{
        printf("not");
    }
    printf("\nall threads exited");
    return 0;
}


DISK FIFO
#include <stdio.h>
#include <stdlib.h>
void fifo(int request[],int n,int head){
    int tsk=0;
    printf("order %d",head);
    for(int i=0;i<n;i++){
    tsk+=abs(request[i]-head);
    head=request[i];
    printf("%d->",head);
    }
    printf("total seek time %d",tsk);
}
int main(){
    int n,head,disk,direction;
    printf("enter the number of requests");
    scanf("%d",&n);
    int request[n];
    printf("enter the request queue");
    for(int i=0;i<n;i++){
        scanf("%d",&request[i]);
    }
    printf("enter the disk size");
    scanf("%d",&disk);
    printf("enter directions 1 for right 0 for left");
    scanf("%d",&direction);
    fifo(request,n,head);
    
}


MEMORY ALLOCATION
#include <stdio.h>
#include <string.h>
void fifo(int block[],int n,int m,int process[]){
    int alloc[n];
    for(int i=0;i<n;i++)
    alloc[i]=-1;
    for(int i=0;i<n;i++){
        for(int j=0;j<m;j++){
            if(block[j]>=process[i]){
                alloc[i]=j;
                block[j]-=process[i];
                break;
            }
        }
    }
    printf("first fit");
    for(int i=0;i<n;i++)
    printf("process %d is allocated to %d\n",i+1,alloc[i]+1);
}
void best(int block[],int n,int m,int process[]){
    int alloc[n];
    for(int i=0;i<n;i++)
    alloc[i]=-1;
    for(int i=0;i<n;i++){
        int bestf=-1;
        for(int j=0;j<m;j++){
            if(block[j]>=process[i] &&( bestf==-1||block[j]<=block[bestf])){
                bestf=j;
            }
        }
        if(bestf!=-1){
            alloc[i]=bestf;
            block[bestf]-=process[i];
        }
    }
    printf("best fit");
    for(int i=0;i<n;i++)
    printf("process %d is allocated to %d\n",i+1,alloc[i]+1);
}
int main(){
    int block[]={100,200,300,400,500};
    int process[]={115,200,340,230};
    int m=sizeof(block)/sizeof(block[0]);
    int n=sizeof(process)/sizeof(process[0]);
    int block1[m], block2[m], block3[m];
    memcpy(block1, block, sizeof(block));
    memcpy(block2, block, sizeof(block));
    fifo(block1,n,m,process);
    best(block2,n,m,process);
}


PAGE FAULT FIFO
#include <stdio.h>
void fifo(int pages[],int n,int cap){
    int frame[cap],ind=0,fault=0;
    for(int i=0;i<cap;i++)
    frame[i]=-1;
    for(int i=0;i<n;i++){
        int page=pages[i];
        int found=0;
        for(int j=0;j<cap;j++){
            if(frame[j]==page){
                found=1;
                break;
            }
        }
        if(!found){
            frame[ind]=page;
            ind=(ind+1)%cap;
            fault++;
        }
        printf("frames:");
        for(int j=0;j<cap;j++){
            if(frame[j]!=-1)
                printf("%d ",frame[j]);
            
            else
                printf("-");
        }
            printf("\n");
    }
    printf("total number of faults%d",fault);
}
int main() 
{
    int pages[] = {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5};
    int n = sizeof(pages) / sizeof(pages[0]);
    int capacity = 3;
    fifo(pages, n, capacity);
}

CPU FCFS
#include <stdio.h>
int main(){
    int n,i;
    int bt[20],wt[20],tt[20];
    float awt=0,att=0;
    printf("enter the number of process\n");
    scanf("%d",&n);
    printf("enter the burst time\n");
    for(int i=0;i<n;i++){
        pr
intf("process %d ",i+1);
        scanf("%d",&bt[i]);
    }
    wt[0]=0;
    for(int i=1;i<n;i++){
        wt[i]=wt[i-1]+bt[i-1];
    }
    for(int i=0;i<n;i++){
        tt[i]=wt[i]+bt[i];
    }
    printf("\nprocess\tbursttime\twaiting\tturnaround\n");
    for(int i=0;i<n;i++){
        printf("%d\t%d\t%d\t%d\n",i+1,bt[i],wt[i],tt[i]);
        awt+=wt[i];
        att+=tt[i];
    }
    printf("\n average waiting %.2f\n",awt);
    printf("turnaround %.2f",att);
}

CPU ROUND ROBIN
#include <stdio.h>
int main() 
{
    int n, quantum, i, time = 0, completed = 0;
    int burst_time[20], remaining_time[20], wait_time[20] = {0}, turn_around_time[20];
    float avg_wait_time = 0, avg_turnaround_time = 0;
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter burst times for each process:\n");
    for (i = 0; i < n; i++)
	{
        printf("Process %d Burst Time: ", i + 1);
        scanf("%d", &burst_time[i]);
        remaining_time[i] = burst_time[i];
    }
    printf("Enter the time quantum: ");
    scanf("%d", &quantum);

    while (completed < n) 
	{
        for (i = 0; i < n; i++) 
		{
            if (remaining_time[i] > 0) 
			{
                if (remaining_time[i] > quantum) 
				{
                    time += quantum;
                    remaining_time[i] -= quantum;
                } else 
				{
                    time += remaining_time[i];
                    wait_time[i] = time - burst_time[i];
                    turn_around_time[i] = time;
                    remaining_time[i] = 0;
                    completed++;
                }
            }
        }
    }
    printf("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (i = 0; i < n; i++) 
	{
        printf("%d\t%d\t\t%d\t\t%d\n", i + 1, burst_time[i], wait_time[i], turn_around_time[i]);
        avg_wait_time += wait_time[i];
        avg_turnaround_time += turn_around_time[i];
    }
    printf("\nAverage Waiting Time: %.2f", avg_wait_time / n);
    printf("Average Turnaround Time: %.2f\n", avg_turnaround_time / n);
}


CPU SJF NONPREEMPTIVE
#include <stdio.h>
int main() {
    int n, i, j, temp;
    int bt[20], wt[20], tt[20], process[20];
    float awt = 0, att = 0;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    printf("Enter the burst times:\n");
    for (i = 0; i < n; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &bt[i]);
        process[i] = i + 1;
    }
    for (i = 0; i < n - 1; i++) {
        for (j = i + 1; j < n; j++) {
            if (bt[i] > bt[j]) {
                temp = bt[i];
                bt[i] = bt[j];
                bt[j] = temp;
                temp = process[i];
                process[i] = process[j];
                process[j] = temp;
            }
        }
    }

    wt[0] = 0;
    for (i = 1; i < n; i++) {
        wt[i] = wt[i - 1] + bt[i - 1];
    }
    for (i = 0; i < n; i++) {
        tt[i] = wt[i] + bt[i];
    }
    printf("\nProcess\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\n", process[i], bt[i], wt[i], tt[i]);
        awt += wt[i];
        att += tt[i];
    }
    printf("\nAverage Waiting Time: %.2f", awt / n);
    printf("\nAverage Turnaround Time: %.2f\n", att / n);
    return 0;
}

NON PREMMEPTIVE PRIORITY
#include <stdio.h>
int main() {
    int n, i, j, temp;
    int bt[20], wt[20], tt[20], priority[20], process[20];
    float awt = 0, att = 0;
    printf("Enter the number of processes: ");
    scanf("%d", &n);
    printf("Enter the burst times and priorities (lower number = higher priority):\n");
    for (i = 0; i < n; i++) {
        process[i] = i + 1; // Process IDs
        printf("Process %d:\n", i + 1);
        printf("Burst Time: ");
        scanf("%d", &bt[i]);
        printf("Priority: ");
        scanf("%d", &priority[i]);
    }
    for (i = 0; i < n - 1; i++) {
        for (j = i + 1; j < n; j++) {
            if (priority[i] > priority[j]) {
                temp = priority[i];
                priority[i] = priority[j];
                priority[j] = temp;
                temp = bt[i];
                bt[i] = bt[j];
                bt[j] = temp;
                temp = process[i];
                process[i] = process[j];
                process[j] = temp;
            }
        }
    }

    wt[0] = 0; 
    for (i = 1; i < n; i++) {
        wt[i] = wt[i - 1] + bt[i - 1];
    }
    for (i = 0; i < n; i++) {
        tt[i] = wt[i] + bt[i];
    }
    printf("\nProcess\tPriority\tBurst Time\tWaiting Time\tTurnaround Time\n");
    for (i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\t\t%d\n", process[i], priority[i], bt[i], wt[i], tt[i]);
        awt += wt[i];
        att += tt[i];
    }

    printf("\nAverage Waiting Time: %.2f", awt / n);
    printf("\nAverage Turnaround Time: %.2f\n", att / n);

    return 0;
}



PAGE FAULT OPTIMAL
#include <stdio.h>
void optimal(int pages[], int n, int capacity) 
{
    int frames[capacity], faults = 0;
    for (int i = 0; i < capacity; i++) frames[i] = -1;
    for (int i = 0; i < n; i++) 
	{
        int page = pages[i];
        int found = 0;
        // Check if the page is already in the frame
        for (int j = 0; j < capacity; j++) 
		{
            if (frames[j] == page) 
			{
                found = 1;
                break;
            }
        }
        // If not found, replace using the optimal algorithm
        if (!found) 
		{
            int replaceIndex = -1, farthest = i;
            for (int j = 0; j < capacity; j++) 
			{
                int nextUse = -1;
                for (int k = i + 1; k < n; k++) 
				{
                    if (pages[k] == frames[j]) 
					{
                        nextUse = k;
                        break;
                    }
                }
                if (nextUse == -1 || nextUse > farthest) 
				{
                    replaceIndex = j;
                    farthest = nextUse;
                }
            }
            frames[replaceIndex] = page;
            faults++;
        }
        // Print the current frame status
        printf("Frame: ");
        for (int j = 0; j < capacity; j++) {
            if (frames[j] != -1) printf("%d ", frames[j]);
            else printf("- ");
        }
        printf("\n");
    }
    printf("Total Page Faults: %d\n", faults);
}
int main() 
{
    int pages[] = {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5};
    int n = sizeof(pages) / sizeof(pages[0]);
    int capacity = 3;
    optimal(pages, n, capacity);
    return 0;
}


PAGEFAULT LRU
#include <stdio.h>
void lru(int pages[], int n, int capacity) 
{
    int frames[capacity], index[capacity], faults = 0;
    for (int i = 0; i < capacity; i++) frames[i] = -1;
    for (int i = 0; i < n; i++) 
	{
        int page = pages[i];
        int found = 0;
        for (int j = 0; j < capacity; j++) 
		{
            if (frames[j] == page) 
			{
                index[j] = i; // Update last used index
                found = 1;
                break;
            }
        }
        // If not found, replace using LRU
        if (!found) 
		{
            int lruIndex = 0;
            for (int j = 1; j < capacity; j++) 
			{
                if (frames[j] == -1 || index[j] < index[lruIndex]) 
				{
                    lruIndex = j;
                }
            }
            frames[lruIndex] = page;
            index[lruIndex] = i;
            faults++;
        }
        // Print the current frame status
        printf("Frame: ");
        for (int j = 0; j < capacity; j++) 
		{
            if (frames[j] != -1) printf("%d ", frames[j]);
            else printf("- ");
        }
        printf("\n");
    }
    printf("Total Page Faults: %d\n", faults);
}
int main() 
{
    int pages[] = {1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5};
    int n = sizeof(pages) / sizeof(pages[0]);
    int capacity = 3;
    lru(pages, n, capacity);
    return 0;
}



INDEXED FILE ALLOCATION
#include <stdio.h>
void indexed_allocation(int index[], int blocks[], int n) 
{
    printf("Indexed File Allocation:\n");
    printf("Index Block Points to: ");
    for (int i = 0; i < n; i++) 
	{
        printf("%d ", blocks[index[i]]);
    }
    printf("\n");
}
int main() 
{
    int index[] = {0, 1, 2, 3};
    int blocks[] = {20, 21, 22, 23};
    int n = sizeof(index) / sizeof(index[0]);
    indexed_allocation(index, blocks, n);
    return 0;
}


SEQUANTIAL ALLOCATION
#include <stdio.h>
void sequential_allocation(int records[], int n) 
{
    printf("Sequential File Allocation:\n");
    for (int i = 0; i < n; i++)
	{
        printf("Record %d is stored in Block %d\n", i + 1, records[i]);
    }
}
int main() 
{
    int records[] = {10, 11, 12, 13, 14};
    int n = sizeof(records) / sizeof(records[0]);
    sequential_allocation(records, n);
}


DINING PHILOSPHERS
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>
#define N 5
sem_t chopstick[N];
void *philosopher(void *num) 
{
    int id = *((int *)num);
    printf("Philosopher %d is thinking\n", id);
if(id%2==0){
        sem_wait(&chopstick[(id + 1) % N]);
        sem_wait(&chopstick[id]);
   
    }
    else{
         sem_wait(&chopstick[id]);
    sem_wait(&chopstick[(id + 1) % N]);
    }
    printf("Philosopher %d is eating\n", id);
    sem_post(&chopstick[id]);
    sem_post(&chopstick[(id + 1) % N]);
    printf("Philosopher %d is done eating\n", id);
    return NULL;
}
int main() 
{
    pthread_t threads[N];
    int philosopher_ids[N];
    for (int i = 0; i < N; i++) 
	{
        sem_init(&chopstick[i], 0, 1);
        philosopher_ids[i] = i;
    }
    for (int i = 0; i < N; i++) 
	{
        pthread_create(&threads[i], NULL, philosopher, &philosopher_ids[i]);
    }
    for (int i = 0; i < N; i++) 
	{
        pthread_join(threads[i], NULL);
    }
}


SINGLE DIRECTORY
#include <stdio.h>
#include <string.h>
struct file 
{
    char name[20];
};
int main() 
{
    struct file directory[10];
    int choice, count = 0;
    char filename[20];
    while (1) 
	{
        printf("\n1. Create File\n2. List Files\n3. Exit\nEnter choice: ");
        scanf("%d", &choice);
        if (choice == 1) 
		{
            printf("Enter file name: ");
            scanf("%s", filename);
            strcpy(directory[count].name, filename);
            count++;
        } else if (choice == 2) 
		{
            printf("Files:\n");
            for (int i = 0; i < count; i++) 
			{
                printf("%s\n", directory[i].name);
            }
        } else 
		{
            break;
        }
    }
}




CPUSCHEDULING PRIOITY PREEMPTIVE
#include <stdio.h>
#include <limits.h>

int main() {
    int n, total = 0, completed = 0, smallest, rt[20], bt[20], ct, wt[20], tt[20], pa[20], at[20], i;
    float awt = 0, att = 0;

    printf("Enter the number of processes: ");
    scanf("%d", &n);

    printf("Enter the arrival time, burst time, and priority for each process:\n");
    for (i = 0; i < n; i++) {
        printf("Process %d Arrival Time: ", i + 1);
        scanf("%d", &at[i]);
        printf("Process %d Burst Time: ", i + 1);
        scanf("%d", &bt[i]);
        printf("Process %d Priority: ", i + 1);
        scanf("%d", &pa[i]);
        rt[i] = bt[i]; // Initialize remaining time
    }

    printf("Process execution order:\n");

    for (ct = 0; completed < n; ct++) {
        smallest = -1;
        for (i = 0; i < n; i++) {
            if (at[i] <= ct && rt[i] > 0) { // Process is ready to execute
                if (smallest == -1 || pa[i] < pa[smallest]) { // Choose highest priority
                    smallest = i;
                }
            }
        }

        if (smallest != -1) {
            printf("Time %d, Process %d executing\n", ct, smallest + 1);
            rt[smallest]--;
            if (rt[smallest] == 0) { // Process is completed
                completed++;
                tt[smallest] = ct + 1 - at[smallest]; // Turnaround time
                wt[smallest] = tt[smallest] - bt[smallest]; // Waiting time
            }
        }
    }

    printf("\nProcess\tArrival Time\tBurst Time\tPriority\tWaiting Time\tTurnaround Time\n");
    for (i = 0; i < n; i++) {
        printf("%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d\n", i + 1, at[i], bt[i], pa[i], wt[i], tt[i]);
        awt += wt[i];
        att += tt[i];
    }

    printf("Average Waiting Time: %.2f\n", awt / n);
    printf("Average Turnaround Time: %.2f\n", att / n);

    return 0;
}



C-SCAN DISK SCHEDULING
#include <stdio.h>
#include <stdlib.h>

void c_scan(int request[], int n, int head, int disk_size) {
    int total_seek_time = 0;
    int sorted[n];
    for (int i = 0; i < n; i++) {
        sorted[i] = request[i];
    }

    // Sort the request queue
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (sorted[i] > sorted[j]) {
                int temp = sorted[i];
                sorted[i] = sorted[j];
                sorted[j] = temp;
            }
        }
    }

    printf("Order of execution: %d", head);

    // Move to the right and wrap around
    for (int i = 0; i < n; i++) {
        if (sorted[i] >= head) {
            total_seek_time += abs(sorted[i] - head);
            head = sorted[i];
            printf(" -> %d", head);
        }
    }

    // Go to the end of the disk and wrap around
    if (head < disk_size - 1) {
        total_seek_time += abs(disk_size - 1 - head);
        head = 0; // Move to the start
        printf(" -> %d", disk_size - 1);
        total_seek_time += abs(disk_size - 1); // Reset to the beginning of the disk
    }

    // Process remaining requests on the left
    for (int i = 0; i < n; i++) {
        if (sorted[i] < head) {
            total_seek_time += abs(sorted[i] - head);
            head = sorted[i];
            printf(" -> %d", head);
        }
    }

    printf("\nTotal Seek Time: %d\n", total_seek_time);
}

int main() {
    int n, head, disk_size;

    printf("Enter the number of requests: ");
    scanf("%d", &n);

    int request[n];
    printf("Enter the request queue: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &request[i]);
    }

    printf("Enter the current head position: ");
    scanf("%d", &head);

    printf("Enter the disk size: ");
    scanf("%d", &disk_size);

    c_scan(request, n, head, disk_size);

    return 0;
}


SCAN DISK SCHEDULING
#include <stdio.h>
#include <stdlib.h>

void scan(int request[], int n, int head, int disk_size, int direction) {
    int total_seek_time = 0;
    int sorted[n];
    for (int i = 0; i < n; i++) {
        sorted[i] = request[i];
    }

    // Sort the request queue
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (sorted[i] > sorted[j]) {
                int temp = sorted[i];
                sorted[i] = sorted[j];
                sorted[j] = temp;
            }
        }
    }

    printf("Order of execution: %d", head);
    if (direction == 1) { // Moving right
        // Process requests to the right of the head
        for (int i = 0; i < n; i++) {
            if (sorted[i] >= head) {
                total_seek_time += abs(sorted[i] - head);
                head = sorted[i];
                printf(" -> %d", head);
            }
        }
        // Go to the end of the disk
        if (head < disk_size - 1) {
            total_seek_time += abs(disk_size - 1 - head);
            head = disk_size - 1;
            printf(" -> %d", head);
        }
        // Process requests to the left of the head
        for (int i = n - 1; i >= 0; i--) {
            if (sorted[i] < head) {
                total_seek_time += abs(sorted[i] - head);
                head = sorted[i];
                printf(" -> %d", head);
            }
        }
    } else { // Moving left
        // Process requests to the left of the head
        for (int i = n - 1; i >= 0; i--) {
            if (sorted[i] <= head) {
                total_seek_time += abs(sorted[i] - head);
                head = sorted[i];
                printf(" -> %d", head);
            }
        }
        // Go to the start of the disk
        if (head > 0) {
            total_seek_time += abs(0 - head);
            head = 0;
            printf(" -> %d", head);
        }
        // Process requests to the right of the head
        for (int i = 0; i < n; i++) {
            if (sorted[i] > head) {
                total_seek_time += abs(sorted[i] - head);
                head = sorted[i];
                printf(" -> %d", head);
            }
        }
    }

    printf("\nTotal Seek Time: %d\n", total_seek_time);
}

int main() {
    int n, head, disk_size, direction;

    printf("Enter the number of requests: ");
    scanf("%d", &n);

    int request[n];
    printf("Enter the request queue: ");
    for (int i = 0; i < n; i++) {
        scanf("%d", &request[i]);
    }

    printf("Enter the current head position: ");
    scanf("%d", &head);

    printf("Enter the disk size: ");
    scanf("%d", &disk_size);

    printf("Enter the direction (1 for right, 0 for left): ");
    scanf("%d", &direction);

    scan(request, n, head, disk_size, direction);

    return 0;
}



MUTEX 
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
int shared=0;
pthread_mutex_t mutex;
void* increment(void* arg){
    int id=*(int*)arg;
    printf("thread %d: waiting for critical section\n",id);
    pthread_mutex_lock(&mutex);
    printf("thread %d: enter the critical section\n",id);
    shared++;
    printf("thread %d: updated shared resources\n",id,shared);
    sleep(1);
    printf("thread %d: exited critical section\n",id);
    pthread_mutex_unlock(&mutex);
    return NULL;
}
int main(){
    pthread_t thread[10];
    int thread_id[20];
    pthread_mutex_init(&mutex,NULL);
    for(int i=0;i<5;i++){
        thread_id[i]=i+1;
        pthread_create(&thread[i],NULL,increment,&thread_id[i]);
    }
    for(int i=0;i<5;i++){
        pthread_join(thread[i],NULL);
    }
    pthread_mutex_destroy(&mutex);
    printf("total shared resources %d",shared);
}


LUNX
#include <unistd.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <stdio.h>

int main()
{
    int n, fd;
    char buff[50]; 
    printf("Enter text to write in the file:\n");
    n = read(0, buff, 50);
    fd = open("file", O_CREAT | O_RDWR, 0777);
    write(fd, buff, n);
    write(1, buff, n);
    int close(int fd);
    return 0;
}
